#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim:ts=4:sw=4:et:ai:sts=4:cinoptions=(0
#
# Copyright 2013 Marín Ferrari <tincho@tincho.org>
#
# This program is loosely based on rss2email, which is Copyright 2004 Aaron
# Swartz, and licensed under the terms of version 2 or 3 of the GNU GPL; with
# contributions from: Dean Jackson, Brian Lalor, Joey Hess, Matej Cepl, Martin
# 'Joey' Schulze, Marcel Ackermann (http://www.DreamFlasher.de), Lindsey Smith
# (maintainer), and Erik Hetzner.
#
# Having said that, this code is written from scratch, and therefore, not a
# derived work.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
"""postfeed: RSS reader by post

Postfeed tracks RSS feeds and posts updates to your email.
"""
__version__ = "0.1"
__author__ = "Martín Ferrari <tincho@tincho.org>"
__copyright__ = "(C) 2013 Martín Ferrari"


import argparse
#from email.mime.text import MIMEText
#import email.utils
import fcntl
import feedparser
import glob
import hashlib
import html2text
import itertools
import os
import re
import sys
import urllib2
#import xml.sax.saxutils
import yaml


MAIN_CONFIG_FILE = 'config.yaml'
FEEDS_CONFIG_DIR = 'feeds'
FEEDS_DB_FILE = 'feeds.db'
DEFAULT_CONFIG_TEXT = """# postfeed configuration (YAML format)

# Default source email address and envelope address.
# default_from: postfeed@localhost

# Default target email address.
# default_to: username

# Send HTML or plain text emails.
# use_html: true

# Use the post author or feed publisher email, when available as the email's
# from address. Can be overridden per-feed with the --force_from option.
# use_author: true

# Priority list to determine which feed field to use for email's date, if
# present. Possible values: 'published', 'created', 'modified'.
# An empty list means to always use the current date.
# date_from: [modified, published, created]

# Send a new email when a post changes, even if the GUID does not.
# repost_changes: false

# List of extra headers to add to the email, unless overridden by the feed
# configuration.
# Python-style string interpolation is performed for the following fields:
#  - feed_name
#  - feed_url
#  - entry_guid
#  - entry_link
#  - entry_title
#  - entry_author
#  - entry_created
#  - entry_published
#  - entry_modified
#  - mail_from
#  - mail_to
# headers: []

# If specified, use a proxy to communicate.
# http_proxy:
# https_proxy:

# If specified, use this command to deliver the email and ignore the SMTP
# parameters. Can be a string to pass to the shell, or an argument array.
# String interpolation is applied with the same rules as 'headers'.
# deliver_cmd: '/usr/lib/sendmail %(mail_to)s'

# This can be used to deliver directly to a mailbox, if using
# dovecot's lda, or equivalent.
# deliver_cmd:
#  - "/usr/lib/dovecot/dovecot-lda"
#  - "-a"
#  - "user+%(feed_name)s@mydomain"
#  - "-u"
#  - "username"
#  - "-m"
#  - "feeds.%(feed_name)s"
"""
DEFAULT_FEED_CONFIG_TEXT = """# postfeed configuration (YAML format)
# This file contains the feeds description. It is regenerated by postfeed,
# comments and formatting are not kept!

# Most options are inherited by default from the main configuration file.
# Options marked with (*) are subject to parameter interpolation, as defined in
# the "headers" option in the main configuration file.

# Feed options:
#   feed_url: feed's URL.
#   force_from: (*) override "From" field in email.
#   force_to: (*) override "To" field in email.
#   use_html: override main configuration value.
#   date_from: override main configuration value.
#   repost_changes: override main configuration value.
#   headers: (*) override main configuration value.
"""


class Error(Exception):
    pass


class ConfigError(Error):
    pass


class DBError(Error):
    pass


class DuplicateFeedError(Error):
    pass


class UnknownFeedError(Error):
    pass


class MainConfiguration(object):
    DEFAULT_CONFIG = {
        'default_from': 'postfeed@localhost',
        'default_to': os.environ.get('USER', None),
        'use_html': True,
        'use_author': True,
        'date_from': ['modified', 'published', 'created'],
        'repost_changes': False,
        'headers': [],
        'http_proxy': None,
        'https_proxy': None,
        'deliver_cmd': '/usr/lib/sendmail %(mail_to)s',
    }

    def __init__(self, config_dir):
        self.config_dir = config_dir
        cfgfile = os.path.join(self.config_dir, MAIN_CONFIG_FILE)
        if not os.path.exists(cfgfile):
            self._create()

        data = yaml.safe_load(open(cfgfile))
        if data is None:
            data = {}
        if not isinstance(data, dict):
            raise ConfigError('Invalid configuration file.')
        config = self.DEFAULT_CONFIG
        for key in config:
            if key in data:
                config[key] = data[key]
            setattr(self, key, config[key])

    def _create(self):
        if not os.path.exists(self.config_dir):
            os.mkdir(self.config_dir)
        cfgfile = os.path.join(self.config_dir, MAIN_CONFIG_FILE)
        with open(cfgfile, 'w') as fd:
            fd.write(DEFAULT_CONFIG_TEXT)
        print 'Default configuration file written to "%s".' % cfgfile

    def as_dict(self):
        config = {}
        for key in self.DEFAULT_CONFIG:
            config[key] = getattr(self, key)
        return config

    def __repr__(self):
        return repr(self.as_dict())


class FeedDB(object):
    def __init__(self, main_configuration, ex_lock=False):
        self._main_config = main_configuration
        self._dbfile = os.path.join(main_configuration.config_dir,
                                    FEEDS_DB_FILE)
        self._feeds_dir = os.path.join(main_configuration.config_dir,
                                       FEEDS_CONFIG_DIR)
        self.feeds = []
        self._feed_urls = {}
        self._ex_lock = ex_lock
        self._fd = None

        if os.path.exists(self._dbfile):
            self._read()
        elif self._ex_lock:
            self._create()

    def _read(self):
        self._fd = open(self._dbfile, 'r+')
        fcntl.lockf(self._fd, fcntl.LOCK_EX if self._ex_lock
                    else fcntl.LOCK_SH)
        data = yaml.safe_load(self._fd)
        if not isinstance(data, list):
            raise ConfigError('Corrupted feeds database.')

        changed = False
        if data is None:
            changed = True
            data = []

        feed_configs = {}
        for name in glob.glob(self._feeds_dir + '/*.conf'):
            config = FeedConfig.from_file(name)
            feed_configs[config.feed_url] = config

        feed_urls = {}
        feeds = []
        for item in data:
            if (
                not isinstance(item, dict) or 'feed_url' not in item or
                'status' not in item
            ):
                raise ConfigError('Corrupted feeds database.')
            feed_url = item['feed_url']
            if feed_url in feed_urls:  # Duplicate
                changed = True
                continue
            if feed_url not in feed_configs:  # Deleted.
                changed = True
                continue

            feed = Feed(feed_configs[feed_url], item['status'])
            feeds.append(feed)
            feed_urls[feed_url] = len(feeds) - 1

        for feed_url, config in feed_configs.iteritems():
            if feed_url not in feed_urls:  # New config.
                feeds.append(feed = Feed(config))
                feed_urls[feed_url] = len(feeds) - 1

        self._feed_urls = feed_urls
        self.feeds = feeds
        if changed and self._ex_lock:
            self.save()

    def _create(self):
        assert self._ex_lock
        if not os.path.exists(self._main_config.config_dir):
            os.mkdir(self._main_config.config_dir)
        if not os.path.exists(self._feeds_dir):
            os.mkdir(self._feeds_dir)

        self._fd = open(self._dbfile, 'w+')
        fcntl.lockf(self._fd, fcntl.LOCK_EX)
        self.save()

    def add(self, feed_config):
        assert self._ex_lock
        if feed_config.feed_url in self._feed_urls:
            raise DuplicateFeedError('The feed URL is already tracked.')
        self.feeds.append(Feed(feed_config))

    def find(self, feed_no_or_url):
        if feed_no_or_url in self._feed_urls:
            return self._feed_urls[feed_no_or_url]
        if feed_no_or_url.isdigit():
            feedno = int(feed_no_or_url)
            if feedno < len(self.feeds):
                return feedno
        raise UnknownFeedError('The feed %s is not in the database.' %
                               feed_no_or_url)

    def delete(self, feedno):
        url = self.feeds[feedno].feed_config.feed_url
        del self._feed_urls[url]
        del self.feeds[feedno]

    def save(self):
        if not self._ex_lock:
            raise Error('Cannot write the DB without an exclusive lock!')
        data = [{'feed_url': feed.feed_config.feed_url,
                 'status': feed.dump()}
                for feed in self.feeds]
        text = yaml.safe_dump(data, default_flow_style=False)
        self._fd.seek(0)
        self._fd.truncate(0)
        self._fd.write(text)
        self._fd.flush()
        self._fd.seek(0)
        os.fsync(self._fd.fileno())

 

class Feed(object):
    DB_FIELDS = {
        'etag': None,
        'modified': None,
        'seen': set(),
        'disabled': False
    }
    def __init__(self, feed_config, dbdata=None):
        self.feed_config = feed_config
        # Always retrieved from the feed.
        self.title = None
        self.subtitle = None
        self.link = None
        if dbdata is None:
            dbdata = {}
        # Status fields, saved in the FeedDB.
        for key, default in self.DB_FIELDS.iteritems():
            setattr(self, key, dbdata.get(key, default))

    def reset(self):
        for key, default in self.DB_FIELDS.iteritems():
            setattr(self, key, default)

    def dump(self):
        data = {}
        for key in self.DB_FIELDS.iterkeys():
            data[key] = getattr(self, key)
        return data

    def fetch(self, global_config):
        feedobj = get_feed(global_config, self.feed_config.feed_url,
                           self.etag, self.modified)

        self.title = feedobj.feed.title
        self.subtitle = feedobj.feed.subtitle
        self.link = feedobj.feed.link

        self.etag = feedobj.get('etag', 'None')
        self.modified = feedobj.get('modified', 'None')

        result = []
        for entry in reversed(feedobj.entries):
            if not entry.id:
                # Serialise and hash the content.
                entry.id = hashlib.sha256(
                    yaml.safe_dump(entry.content)
                ).hexdigest()

            if entry.id in self.seen:
                continue
            self.seen.add(entry.id)

            result.append(process_entry(entry))

        return result


class FeedConfig(object):
    CONFIG_KEYS = set([
        'feed_url',
        'feed_name',
        'force_from',
        'force_to',
        'use_html',
        'date_from',
        'repost_changes',
        'headers',
    ])

    def __init__(self, feed_name, feed_url,
                 force_from=None, force_to=None,
                 use_html=None, date_from=None, repost_changes=None,
                 headers=None, filename=None):
        self.feed_name = feed_name
        self.feed_url = feed_url
        self.force_from = force_from
        self.force_to = force_to
        self.use_html = use_html
        self.date_from = date_from
        self.repost_changes = repost_changes
        self.headers = headers
        if filename:
            self.filename = filename
        else:
            clean_name = re.sub(r'\W+', '_', feed_name)
            self.filename = clean_name + '.conf'

    @classmethod
    def from_file(cls, filename):
        with open(filename) as fd:
            data = yaml.safe_load(fd)
            if data is None:
                data = {}
            if not isinstance(data, dict):
                raise ConfigError('Invalid feed configuration file %r.' %
                                  filename)
            if (
                'feed_url' not in data or not data['feed_url'] or
                'feed_name' not in data or not data['feed_name']
            ):
                raise ConfigError('Invalid feed description: %r' % data)
            unknown_keys = set(data.iterkeys()) - cls.CONFIG_KEYS
            if unknown_keys:
                raise ConfigError(
                    'Invalid keys in feed configuration file %r: %s.' %
                    (filename, unknown_keys))
        return cls(filename=os.path.basename(filename), **data)

    def save(self, directory):
        config = {}
        for key in self.CONFIG_KEYS:
            config[key] = getattr(self, key)
        filename = os.path.join(directory, self.filename)
        with open(filename, 'w') as fd:
            fd.write(DEFAULT_FEED_CONFIG_TEXT)
            yaml.safe_dump(config, fd, default_flow_style=False)

    def delete(self, directory):
        filename = os.path.join(directory, self.filename)
        os.unlink(filename)


def parse_cmdline(argv):
    # create the top-level parser
    parser = argparse.ArgumentParser(
        usage='%(prog)s [-d DIR] subcommand [options]',
        add_help=False, description=('Postfeed tracks RSS feeds and posts '
                                     'updates to your email.'))
    parser.add_argument('-h', '--help', action='help', help=argparse.SUPPRESS)
    parser.add_argument('-d', '--dir', default='~/.postfeed',
                        dest='config_dir', type=os.path.expanduser,
                        help='Configuration directory')
    parser.add_argument('--version', action='version',
                        version='%(prog)s ' + __version__)

    subparsers = parser.add_subparsers(title='subcommands', dest='cmd')
    subparser = {}
    for cmd, hlp_ in (('run', 'Update feeds and mail posts.'),
                      ('add', 'Add a new feed.'),
                      ('set', 'Configure a feed.'),
                      ('list', 'List configured feeds.'),
                      ('delete', 'Delete feed.'),
                      ('reset', 'Reset feed data (posts will be resent).'),
                      ('disable', 'Disable feed.'),
                      ('enable', 'Enable feed.'),
                      ('opmlexport', 'Export feed list as OMPL.'),
                      ('opmlimport', 'Import feeds from an OMPL description.'),
                      ('help', 'Get usage help.'),
                      ):
        subparser[cmd] = subparsers.add_parser(
            cmd, help=hlp_, add_help=False,
            prog="%s [-d DIR] %s" % (parser.prog, cmd))
        subparser[cmd].add_argument('-h', '--help', action='help',
                                    help=argparse.SUPPRESS)

    subparser['run'].add_argument(
        'feed', nargs='?',
        help='Restrict operation to this feed name or number.')
    for cmd in ('add', 'set'):
        subparser[cmd].add_argument(
            'feed_url', help='Feed source URL.')
        subparser[cmd].add_argument(
            '--name', help='Name for the feed (defaults to the feed\'s title).')
        subparser[cmd].add_argument(
            '--force_from', metavar="EMAIL", help='Fixed "From" field.')
        subparser[cmd].add_argument(
            '--force_to', metavar="EMAIL", help='Fixed "To" field.')
        subparser[cmd].add_argument(
            '--use_html', metavar="",
            help='Send HTML or plain text emails (overrides config).')
        subparser[cmd].add_argument(
            '--date_from', metavar="EMAIL",
            help='Send HTML or plain text emails (overrides config).')
        subparser[cmd].add_argument(
            '--repost_changes', metavar="EMAIL", help='Fixed "To" field.')
        subparser[cmd].add_argument(
            '--headers', metavar="EMAIL", help='Fixed "To" field.')
    for cmd in ('delete', 'reset', 'enable', 'disable'):
        subparser[cmd].add_argument(
            'feed', help='Feed URL or number to %s.' % cmd)
    subparser['opmlimport'].add_argument(
        'file', type=file, help='OPML file to import from.')

    subparser['help'].add_argument(
        'subcommand', nargs='?', help='Get help for this subcommand.')
    subparser['help'].set_defaults(parser=parser, subparser=subparser)

    return parser.parse_args(argv)


def get_proxyhandler(http_proxy=None, https_proxy=None):
    proxies = {}
    if http_proxy:
        proxies['http'] = http_proxy
    if https_proxy:
        proxies['https'] = https_proxy
    return urllib2.ProxyHandler(proxies)


def get_feed(config, feed_url, *args, **kwargs):
    if config.http_proxy or config.https_proxy:
        handler = get_proxyhandler(config.http_proxy, config.https_proxy)
        feedobj = feedparser.parse(feed_url, *args, handlers=[handler],
                                   **kwargs)
    else:
        feedobj = feedparser.parse(feed_url, *args, **kwargs)
    if feedobj.bozo:
        raise feedobj.bozo_exception
    return feedobj


def txt2html(text):
    return text  # FIXME


def get_text_and_html(detail):
    html_contents = []
    text_contents = []
    for item in detail:
        if item.type in ('text/html', 'application/xhtml+xml'):
            html_contents.append(item)
        elif item.type == 'text/plain':
            text_contents.append(item)

    if html_contents:
        html_content = html_contents[0].value
    elif text_contents:
        html_content = txt2html(text_contents[0].value)
    else:
        html_content = None

    if text_contents:
        text_content = text_contents[0].value
    elif html_contents:
        baseurl = html_contents[0].get('base', '')
        h2t = html2text.HTML2Text(baseurl=baseurl)
        h2t.unicode_snob = True
        h2t.inline_links = False
        text_content = h2t.handle(html_contents[0].value)
    else:
        text_content = None

    return text_content, html_content


def process_entry(entry):
    text_content, html_content = get_text_and_html(
        entry.content + [entry.summary_detail])
    text_title, html_title = (get_text_and_html([entry.title_detail])
                              if 'title_detail' in entry else (None, None))
    if 'author_detail' in entry:
        author = (
            entry.author_detail.get('name', None),
            entry.author_detail.get('href', None),
            entry.author_detail.get('email', None),
        )
    else:
        author = (None, None, None)

    return {
        'id': entry.id,
    	'link': entry.get('link', None),
    	'comments': entry.get('comments', None),
    	'updated': entry.get('updated_parsed', None),
    	'published': entry.get('published_parsed', None),
    	'tags': entry.get('tags', None),
        'text_content': text_content,
        'html_content': html_content,
        'text_title': text_title,
        'html_title': html_title,
        'author': author,
    }


def main():
    cmdtable = {
        'run': do_run,
        'add': do_add,
        'list': do_list,
        'delete': do_delete,
        'reset': do_reset,
        'disable': do_disable,
        'enable': do_enable,
        'opmlexport': do_opmlexport,
        'opmlimport': do_opmlimport,
    }
    args = parse_cmdline(sys.argv[1:])
    if args.cmd == 'help':
        do_help(args)
    else:
        try:
            config = MainConfiguration(args.config_dir)
            cmdtable[args.cmd](config, args)
        except Exception as exc:
            print >>sys.stderr, 'Error: %s' % exc
            raise
            sys.exit(1)


def do_help(args):
    if args.subcommand and args.subcommand in args.subparser:
        args.subparser[args.subcommand].print_help()
    else:
        args.parser.print_help()
        args.parser.exit()


def do_run(config, args):
    feeddb = FeedDB(config, ex_lock=True)
    if args.feed:
        feedno = feeddb.find(args.feed)
        feeds = [feeddb.feeds[feedno]]
    else:
        feeds = feeddb.feeds

    for feed in feeds:
        if feed.disabled:
            continue
        new_entries = feed.fetch(config)

        use_html = (feed.feed_config.use_html
                    if feed.feed_config.use_html is not None
                    else config.use_html)

        print "%s - %s" % (feed.title, feed.subtitle)
        for entry in new_entries:
            print entry['text_title'], entry['author']
            print entry['text_content']

    feeddb.save()


def do_add(config, args):
    feeddb = FeedDB(config, ex_lock=True)

    name = args.name
    if not name:
        feedobj = get_feed(config, args.feed_url)
        name = feedobj.feed.get('title', args.feed_url)

    feedconf = FeedConfig(feed_name=name, feed_url=args.feed_url,
                          force_from=args.force_from, force_to=args.force_to)
    feeddb.add(feedconf)
    feedconf.save(os.path.join(config.config_dir, FEEDS_CONFIG_DIR))
    feeddb.save()


def do_list(config, args):
    feeddb = FeedDB(config, ex_lock=False)
    for feedno in xrange(len(feeddb.feeds)):
        feed = feeddb.feeds[feedno]
        feedc = feed.feed_config
        print '%d. %s [%s]%s' % (feedno, feedc.feed_name, feedc.feed_url,
                                 ' (disabled)' if feed.disabled else '')


def do_delete(config, args):
    feeddb = FeedDB(config, ex_lock=True)
    feedno = feeddb.find(args.feed)
    feed = feeddb.feeds[feedno]
    feed.feed_config.delete(os.path.join(config.config_dir, FEEDS_CONFIG_DIR))
    feeddb.delete(feedno)
    feeddb.save()


def do_reset(config, args):
    feeddb = FeedDB(config, ex_lock=True)
    feedno = feeddb.find(args.feed)
    feeddb.feeds[feedno].reset()
    feeddb.save()


def do_disable(config, args):
    feeddb = FeedDB(config, ex_lock=True)
    feedno = feeddb.find(args.feed)
    feeddb.feeds[feedno].disabled = True
    feeddb.save()


def do_enable(config, args):
    feeddb = FeedDB(config, ex_lock=True)
    feedno = feeddb.find(args.feed)
    feeddb.feeds[feedno].disabled = False
    feeddb.save()


def do_opmlexport(): pass
def do_opmlimport(): pass


if __name__ == '__main__':
    main()
